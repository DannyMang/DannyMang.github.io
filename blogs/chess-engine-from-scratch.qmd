---
title: "Building a Chess Engine from Scratch"
author: "Daniel Ung"
date: "2024-01-16"
categories: [chess, ai, algorithms, python]
image: "chess-preview.jpg"
draft: false
format:
  html:
    code-fold: false
    code-tools: true
---

tl:dr, how to represent a chess game programmatically?

## Chess Engine Architecture Overview

The first decision is how to represent the chess board. We have several options:

### Option 1: 8x8 Array (Simple but Inefficient)

``` python
class SimpleBoard:
    def __init__(self):
        # 8x8 board with piece codes
        self.board = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ]
    
    def get_piece(self, row, col):
        return self.board[row][col]
    
    def set_piece(self, row, col, piece):
        self.board[row][col] = piece
```

### Option 2: Bitboards (More Computationally Efficient, we are going with this)

``` python
class BitBoard:
    def __init__(self):
        # Each piece type gets its own 64-bit integer
        # We are basically just representing EVERYTHING in chess in 0s and 1s
        self.white_pawns = 0x000000000000FF00
        self.white_knights = 0x0000000000000042
        self.white_bishops = 0x0000000000000024
        self.white_rooks = 0x0000000000000081
        self.white_queens = 0x0000000000000008
        self.white_king = 0x0000000000000010
        
        self.black_pawns = 0x00FF000000000000
        self.black_knights = 0x4200000000000000
        # ... and so on
    
```

But how do we represent moves? Positions? Attacks?

Bitmasks. Lots of them. Lets go more into depth about bitboards

### Understanding Bitboard Mapping

A bitboard uses a 64-bit integer where each bit represents one square on the chess board. 

```
Chess Board Layout:
  a b c d e f g h
8 ♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜  8
7 ♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟  7
6 . . . . . . . .  6
5 . . . . . . . .  5
4 . . . . . . . .  4
3 . . . . . . . .  3
2 ♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙  2
1 ♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖  1
  a b c d e f g h

Bitboard Square Numbers (0-63):
   0  1  2  3  4  5  6  7   <- a8-h8 (rank 8)
   8  9 10 11 12 13 14 15   <- a7-h7 (rank 7)
  16 17 18 19 20 21 22 23   <- a6-h6 (rank 6)
  24 25 26 27 28 29 30 31   <- a5-h5 (rank 5)
  32 33 34 35 36 37 38 39   <- a4-h4 (rank 4)
  40 41 42 43 44 45 46 47   <- a3-h3 (rank 3)
  48 49 50 51 52 53 54 55   <- a2-h2 (rank 2)
  56 57 58 59 60 61 62 63   <- a1-h1 (rank 1)
  
 Note: Each bit position represents 2^position. For example:
 1000 0001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
 represents 2^63 + 2^56 (bits 63 and 56 are flipped/set to 1)


```

### Binary Representation Example

Let's look at the initial white pawns position:

```python
# White pawns start on rank 2 (squares 48-55)
white_pawns = 0x000000000000FF00 = 
# 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1111 1111 0000 0000 <-- see where the 1's are 


# In binary (64 bits): 
# Bit position: 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 ... 7 6 5 4 3 2 1 0
# Binary:        0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1 ... 0 0 0 0 0 0 0 0
# Square:      a1 b1 c1 d1 e1 f1 g1 h1 a2 b2 c2 d2 e2 f2 g2 h2 ...

# Visualized on 8x8 board (1 = pawn present, 0 = empty):
#   a b c d e f g h
# 8 0 0 0 0 0 0 0 0
# 7 0 0 0 0 0 0 0 0
# 6 0 0 0 0 0 0 0 0
# 5 0 0 0 0 0 0 0 0
# 4 0 0 0 0 0 0 0 0
# 3 0 0 0 0 0 0 0 0
# 2 1 1 1 1 1 1 1 1  <- White pawns here
# 1 0 0 0 0 0 0 0 0

#So for BLACK bishops, it would look something like this: 

black_bishops = 0x2400000000000000 = 
# = 0000 0010 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 <-- notice the 1's in the 3rd and 6th positions

#   a b c d e f g h
# 8 0 0 1 0 0 1 0 0  <- Black bishops on c8 and f8
# 7 0 0 0 0 0 0 0 0
# 6 0 0 0 0 0 0 0 0
# 5 0 0 0 0 0 0 0 0
# 4 0 0 0 0 0 0 0 0
# 3 0 0 0 0 0 0 0 0
# 2 0 0 0 0 0 0 0 0
# 1 0 0 0 0 0 0 0 0
```


## Step 2: Move Generation

Next, we need to generate all legal moves for a given position:

For this part, the following is helpful to know:

We use bitwise operations such as BITWISE OR/AND to what we need. 
Ex:  We can get all white positions by BITWISE ORing all the white pieces together. 

all_white_positions = white_pawns | white_knights | white_bishops | white_rooks | white_queens | white_king
So imagine we have white_pawns = 0x000000000000FF00 and white_knights = 0x0000000000000042 .....
We would get a result of 0x000000000000FF42 ... as well as all the other white pieces together. 

We could also do all_positions = white_positions | black_positions to get all positions on the board. You can kind of see how this is super helpful now.

For each file, we can generate masks that can help us filter moves. 
Ex: If we want File A or file H, we can represent that as file_A = 0x8080808080808080 and file_H=  0x0101010101010101 , same goes for other diagonals, rows, and columns.

For special cases such as en passant, and castling, we could have a bitmask like castling_rights = 0b1111 representing the 4 possible castling moves (black or white kingside or queenside etc), and flip them when we do castle. 


``` python
# For reference this is kind of what they look like 
A_FILE = 0x0101010101010101  # a1, a2, a3, ..., a8
# A_FILE = 0000 0001 0000 0001 0000 0001 0000 0001 0000 0001 0000 0001 0000 0001 0000 0001
H_FILE = 0x8080808080808080  # h1, h2, h3, ..., h8
# H_FILE = 1000 0000 1000 0000 1000 0000 1000 0000 1000 0000 1000 0000 1000 0000 1000 0000

# Rank masks (horizontal rows)  
RANK_1 = 0x00000000000000FF  # a1, b1, c1, ..., h1
RANK_8 = 0xFF00000000000000  # a8, b8, c8, ..., h8

# Diagonal masks
MAIN_DIAGONAL = 0x8040201008040201  # a1-h8 diagonal
ANTI_DIAGONAL = 0x0102040810204080  # h1-a8 diagonal
```

Now for the actual move generation. 

We can do different things for different pieces. 

For pawns, we can just generate all the possible moves for each pawn. 
For knights, we can just generate all the possible moves for each knight. 
etc etc. 


This would look something like the following:

``` python
class MoveGenerator:
    def __init__(self):
        # Pre-computed attack masks for different pieces
        self.knight_attacks = self.generate_knight_attack_table()
        self.king_attacks = self.generate_king_attack_table()
        
        # File and rank masks
        self.file_masks = self.generate_file_masks()
        self.rank_masks = self.generate_rank_masks()
        
    def generate_pawn_moves(self, board, color):
        """Generate all pawn moves using bitboard operations"""
        if color == 'white':
            pawns = board.white_pawns
            enemies = board.get_black_pieces()
            all_pieces = board.get_all_pieces()
            
            # Single pawn pushes
            # pawns << 8 means "shift all pawn bits 8 positions to the left"
            # This moves each pawn forward by one rank (8 squares = 1 rank)
            single_pushes = (pawns << 8) & ~all_pieces
            
            # Double pawn pushes (only from rank 2)
            double_pushes = ((single_pushes & 0x0000000000FF0000) << 8) & ~all_pieces
            
            # Pawn captures (diagonal attacks)
            left_attacks = ((pawns & ~0x8080808080808080) << 7) & enemies  # Not on H-file
            right_attacks = ((pawns & ~0x0101010101010101) << 9) & enemies  # Not on A-file
            
            return single_pushes | double_pushes | left_attacks | right_attacks
            
        else:  # black pawns
            pawns = board.black_pawns
            enemies = board.get_white_pieces()
            all_pieces = board.get_all_pieces()
            
            # Single pawn pushes (black moves "down" the board)
            single_pushes = (pawns >> 8) & ~all_pieces
            
            # Double pawn pushes (only from rank 7)
            # Same as above but the AND is flipped 
            double_pushes = ((single_pushes & 0x0000FF0000000000) >> 8) & ~all_pieces
            
            # Pawn captures
            left_attacks = ((pawns & ~0x0101010101010101) >> 7) & enemies  # Not on A-file
            right_attacks = ((pawns & ~0x8080808080808080) >> 9) & enemies  # Not on H-file
            
            return single_pushes | double_pushes | left_attacks | right_attacks

```

What about sliding pieces? Rooks? Bishops? Queens? These pieces are kind of difficult to represent since pieces in the way of their sliding attack effectively blocks a lot of their paths. Much harder to compute.

This is where we bring in the "magic" bitboards. Josh Watzman's article https://essays.jwatzman.org/essays/chess-move-generation-with-magic-bitboards.html explains this in detail. 

Basically, we just construct a giant hashtable for all the moves made by those pieces. Thats the magic. 

For Kings and Knights, they're moves are fixed. Much easier to compute. No need for magic bitboards with them. 



## Step 3 : RL application in Chess

Okay I am skipping over a bunch of the bitboard stuff but the top part should be sufficient enough to get an idea.


TO-DO


## Sources and References

### Technical Resources
- **Chess Programming Wiki** - [Comprehensive resource for chess programming](https://www.chessprogramming.org/)
- **Magic Bitboards Explained** - [Josh Watzman's detailed article](https://essays.jwatzman.org/essays/chess-move-generation-with-magic-bitboards.html)
- **Stockfish Source Code** - [World's strongest open-source engine](https://github.com/official-stockfish/Stockfish)
- **Bitboard Basics** - [Chess Programming Wiki Bitboards](https://www.chessprogramming.org/Bitboards)

### Academic Papers
- **Computer Chess Programming** - Shannon, Claude (1950). "Programming a Computer for Playing Chess"
- **Alpha-Beta Pruning** - Knuth, Donald & Moore, Ronald (1975). "An analysis of alpha-beta pruning"

### Community and Forums
- **Computer Chess Club** - [Active community of chess programmers](http://www.talkchess.com/)
- **Chess Programming Discord** - Real-time discussions and help
- **Reddit r/ComputerChess** - [Chess programming community](https://reddit.com/r/ComputerChess)

### Testing and Benchmarking
- **Perft Testing** - [Move generation verification](https://www.chessprogramming.org/Perft)
- **EPD Test Suites** - [Engine testing positions](https://www.chessprogramming.org/Extended_Position_Description)
- **CCRL Rating Lists** - [Computer Chess Rating Lists](https://ccrl.chessdom.com/)

### Historical Context
- **Deep Blue vs Kasparov** - IBM's historic chess computer match (1997)
- **Shannon's Paper** - The foundational work on computer chess (1950)
- **Belle and Cray Blitz** - Early chess computers that shaped the field

------------------------------------------------------------------------

*Happy coding! Feel free to reach out to me to discuss further!*